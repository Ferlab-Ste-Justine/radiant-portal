/* tslint:disable */
/* eslint-disable */
/**
 * Radiant API
 * This is the API for Radiant data platform.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Aggregation represents an aggregation result
 * @export
 * @interface Aggregation
 */
export interface Aggregation {
    /**
     * Count in the bucket
     * @type {number}
     * @memberof Aggregation
     */
    'count'?: number;
    /**
     * Bucket key
     * @type {string}
     * @memberof Aggregation
     */
    'key'?: string;
}
/**
 * 
 * @export
 * @interface AggregationBody
 */
export interface AggregationBody {
    /**
     * 
     * @type {string}
     * @memberof AggregationBody
     */
    'field'?: string;
    /**
     * 
     * @type {number}
     * @memberof AggregationBody
     */
    'size'?: number;
    /**
     * 
     * @type {Sqon}
     * @memberof AggregationBody
     */
    'sqon'?: Sqon;
}
/**
 * ApiError represents an error
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * 
     * @type {any}
     * @memberof ApiError
     */
    'detail'?: any;
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof ApiError
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface AutoCompleteTerm
 */
export interface AutoCompleteTerm {
    /**
     * 
     * @type {Term}
     * @memberof AutoCompleteTerm
     */
    'highlight'?: Term;
    /**
     * 
     * @type {Term}
     * @memberof AutoCompleteTerm
     */
    'source'?: Term;
}
/**
 * Count represents count result
 * @export
 * @interface Count
 */
export interface Count {
    /**
     * Number of results
     * @type {number}
     * @memberof Count
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface CountBody
 */
export interface CountBody {
    /**
     * 
     * @type {Sqon}
     * @memberof CountBody
     */
    'sqon'?: Sqon;
}
/**
 * 
 * @export
 * @interface ExpendedOccurrence
 */
export interface ExpendedOccurrence {
    /**
     * 
     * @type {string}
     * @memberof ExpendedOccurrence
     */
    'aa_change'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'ad_alt'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'ad_total'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'cadd_phred'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'cadd_score'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ExpendedOccurrence
     */
    'canonical'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ExpendedOccurrence
     */
    'coding_dna_change'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExpendedOccurrence
     */
    'fathmm_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'fathmm_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpendedOccurrence
     */
    'filter'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'genotype_quality': number;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'gnomad_loeuf'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'gnomad_pli'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'gnomad_v3_af': number;
    /**
     * 
     * @type {string}
     * @memberof ExpendedOccurrence
     */
    'hgvsg': string;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'locus_id': number;
    /**
     * 
     * @type {boolean}
     * @memberof ExpendedOccurrence
     */
    'mane_select'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExpendedOccurrence
     */
    'picked_consequences': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'qd'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'revel_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpendedOccurrence
     */
    'rsnumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExpendedOccurrence
     */
    'sift_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'sift_score'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpendedOccurrence
     */
    'spliceai_ds'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExpendedOccurrence
     */
    'spliceai_type'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ExpendedOccurrence
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExpendedOccurrence
     */
    'vep_impact'?: ExpendedOccurrenceVepImpactEnum;
}

export const ExpendedOccurrenceVepImpactEnum = {
    Modifier: 'MODIFIER',
    Low: 'LOW',
    Moderate: 'MODERATE',
    High: 'HIGH'
} as const;

export type ExpendedOccurrenceVepImpactEnum = typeof ExpendedOccurrenceVepImpactEnum[keyof typeof ExpendedOccurrenceVepImpactEnum];

/**
 * 
 * @export
 * @interface InterpretationGermline
 */
export interface InterpretationGermline {
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'classification'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InterpretationGermline
     */
    'classification_criterias'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'condition'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'created_by_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'interpretation'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'locus_id'?: string;
    /**
     * 
     * @type {InterpretationMetadata}
     * @memberof InterpretationGermline
     */
    'metadata'?: InterpretationMetadata;
    /**
     * 
     * @type {Array<InterpretationPubmed>}
     * @memberof InterpretationGermline
     */
    'pubmed'?: Array<InterpretationPubmed>;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'sequencing_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'transcript_id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InterpretationGermline
     */
    'transmission_modes'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'updated_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationGermline
     */
    'updated_by_name'?: string;
}
/**
 * 
 * @export
 * @interface InterpretationMetadata
 */
export interface InterpretationMetadata {
    /**
     * 
     * @type {string}
     * @memberof InterpretationMetadata
     */
    'analysis_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationMetadata
     */
    'patient_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationMetadata
     */
    'variant_hash'?: string;
}
/**
 * 
 * @export
 * @interface InterpretationPubmed
 */
export interface InterpretationPubmed {
    /**
     * 
     * @type {string}
     * @memberof InterpretationPubmed
     */
    'citation'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationPubmed
     */
    'citation_id'?: string;
}
/**
 * 
 * @export
 * @interface InterpretationSomatic
 */
export interface InterpretationSomatic {
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'clinical_utility'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'created_by_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'interpretation'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'locus_id'?: string;
    /**
     * 
     * @type {InterpretationMetadata}
     * @memberof InterpretationSomatic
     */
    'metadata'?: InterpretationMetadata;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'oncogenicity'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InterpretationSomatic
     */
    'oncogenicity_classification_criterias'?: Array<string>;
    /**
     * 
     * @type {Array<InterpretationPubmed>}
     * @memberof InterpretationSomatic
     */
    'pubmed'?: Array<InterpretationPubmed>;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'sequencing_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'transcript_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'tumoral_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'updated_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationSomatic
     */
    'updated_by_name'?: string;
}
/**
 * 
 * @export
 * @interface LeafContent
 */
export interface LeafContent {
    /**
     * 
     * @type {string}
     * @memberof LeafContent
     */
    'field'?: string;
    /**
     * 
     * @type {Array<any>}
     * @memberof LeafContent
     */
    'value'?: Array<any>;
}
/**
 * Body of a list request
 * @export
 * @interface ListBody
 */
export interface ListBody {
    /**
     * 
     * @type {Array<string>}
     * @memberof ListBody
     */
    'additional_fields'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ListBody
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListBody
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListBody
     */
    'page_index'?: number;
    /**
     * 
     * @type {Array<SortBody>}
     * @memberof ListBody
     */
    'sort'?: Array<SortBody>;
    /**
     * 
     * @type {Sqon}
     * @memberof ListBody
     */
    'sqon'?: Sqon;
}
/**
 * Occurrence represents an occurrence
 * @export
 * @interface Occurrence
 */
export interface Occurrence {
    /**
     * 
     * @type {string}
     * @memberof Occurrence
     */
    'aa_change'?: string;
    /**
     * 
     * @type {number}
     * @memberof Occurrence
     */
    'ad_ratio': number;
    /**
     * 
     * @type {number}
     * @memberof Occurrence
     */
    'af'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Occurrence
     */
    'canonical'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Occurrence
     */
    'chromosome'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Occurrence
     */
    'clinvar'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Occurrence
     */
    'filter'?: string;
    /**
     * 
     * @type {number}
     * @memberof Occurrence
     */
    'genotype_quality': number;
    /**
     * 
     * @type {number}
     * @memberof Occurrence
     */
    'gnomad_v3_af': number;
    /**
     * 
     * @type {string}
     * @memberof Occurrence
     */
    'hgvsg': string;
    /**
     * 
     * @type {string}
     * @memberof Occurrence
     */
    'impact_score'?: string;
    /**
     * 
     * @type {number}
     * @memberof Occurrence
     */
    'locus_id': number;
    /**
     * 
     * @type {boolean}
     * @memberof Occurrence
     */
    'mane_select'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Occurrence
     */
    'omim_inheritance_code'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Occurrence
     */
    'pc'?: number;
    /**
     * 
     * @type {number}
     * @memberof Occurrence
     */
    'pf': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Occurrence
     */
    'picked_consequences': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Occurrence
     */
    'rsnumber'?: string;
    /**
     * 
     * @type {number}
     * @memberof Occurrence
     */
    'seq_id': number;
    /**
     * 
     * @type {string}
     * @memberof Occurrence
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof Occurrence
     */
    'transcript_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Occurrence
     */
    'variant_class': string;
    /**
     * 
     * @type {string}
     * @memberof Occurrence
     */
    'vep_impact'?: OccurrenceVepImpactEnum;
    /**
     * 
     * @type {string}
     * @memberof Occurrence
     */
    'zygosity': string;
}

export const OccurrenceVepImpactEnum = {
    Modifier: 'MODIFIER',
    Low: 'LOW',
    Moderate: 'MODERATE',
    High: 'HIGH'
} as const;

export type OccurrenceVepImpactEnum = typeof OccurrenceVepImpactEnum[keyof typeof OccurrenceVepImpactEnum];

/**
 * 
 * @export
 * @interface OmimGeneSet
 */
export interface OmimGeneSet {
    /**
     * 
     * @type {Array<string>}
     * @memberof OmimGeneSet
     */
    'inheritance_code'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof OmimGeneSet
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OmimGeneSet
     */
    'omim_id'?: string;
}
/**
 * 
 * @export
 * @interface PubmedCitation
 */
export interface PubmedCitation {
    /**
     * 
     * @type {string}
     * @memberof PubmedCitation
     */
    'id'?: string;
    /**
     * 
     * @type {PubmedCitationDetails}
     * @memberof PubmedCitation
     */
    'nlm'?: PubmedCitationDetails;
}
/**
 * 
 * @export
 * @interface PubmedCitationDetails
 */
export interface PubmedCitationDetails {
    /**
     * 
     * @type {string}
     * @memberof PubmedCitationDetails
     */
    'format'?: string;
}
/**
 * Sequencing represents a sequencing
 * @export
 * @interface Sequencing
 */
export interface Sequencing {
    /**
     * 
     * @type {string}
     * @memberof Sequencing
     */
    'analysis_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sequencing
     */
    'experiment_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof Sequencing
     */
    'patient_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Sequencing
     */
    'sample_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Sequencing
     */
    'seq_id'?: number;
}
/**
 * 
 * @export
 * @interface SortBody
 */
export interface SortBody {
    /**
     * 
     * @type {string}
     * @memberof SortBody
     */
    'field'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortBody
     */
    'order'?: SortBodyOrderEnum;
}

export const SortBodyOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type SortBodyOrderEnum = typeof SortBodyOrderEnum[keyof typeof SortBodyOrderEnum];

/**
 * 
 * @export
 * @interface Sqon
 */
export interface Sqon {
    /**
     * 
     * @type {SqonContent}
     * @memberof Sqon
     */
    'content'?: SqonContent;
    /**
     * 
     * @type {string}
     * @memberof Sqon
     */
    'op'?: SqonOpEnum;
}

export const SqonOpEnum = {
    In: 'in',
    And: 'and',
    Or: 'or',
    Not: 'not',
    Between: 'between',
    GreaterThan: '>',
    LessThan: '<',
    GreaterThanOrEqualTo: '>=',
    LessThanOrEqualTo: '<=',
    NotIn: 'not-in',
    All: 'all'
} as const;

export type SqonOpEnum = typeof SqonOpEnum[keyof typeof SqonOpEnum];

/**
 * @type SqonContent
 * @export
 */
export type SqonContent = Array<Sqon> | LeafContent;

/**
 * Statistics represents statistics about a column
 * @export
 * @interface Statistics
 */
export interface Statistics {
    /**
     * Max for numeric facet
     * @type {number}
     * @memberof Statistics
     */
    'max'?: number;
    /**
     * Min for numeric facet
     * @type {number}
     * @memberof Statistics
     */
    'min'?: number;
}
/**
 * 
 * @export
 * @interface StatisticsBody
 */
export interface StatisticsBody {
    /**
     * 
     * @type {string}
     * @memberof StatisticsBody
     */
    'field'?: string;
    /**
     * 
     * @type {Sqon}
     * @memberof StatisticsBody
     */
    'sqon'?: Sqon;
}
/**
 * 
 * @export
 * @interface Term
 */
export interface Term {
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface UserSet
 */
export interface UserSet {
    /**
     * 
     * @type {boolean}
     * @memberof UserSet
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserSet
     */
    'id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserSet
     */
    'ids'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UserSet
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSet
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSet
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSet
     */
    'user_id'?: string;
}
/**
 * 
 * @export
 * @interface VariantOverview
 */
export interface VariantOverview {
    /**
     * TODO
     * @type {string}
     * @memberof VariantOverview
     */
    'assembly_version'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'cadd_phred'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'cadd_score'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantOverview
     */
    'clinvar'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'coding_dna_change'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'dann_score'?: number;
    /**
     * TODO
     * @type {number}
     * @memberof VariantOverview
     */
    'exon_rank'?: number;
    /**
     * TODO
     * @type {number}
     * @memberof VariantOverview
     */
    'exon_total'?: number;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'fathmm_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'fathmm_score'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'gnomad_loeuf'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'gnomad_pli'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'gnomad_v3_af': number;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'hgvsg': string;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'locus': string;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'lrt_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'lrt_score'?: number;
    /**
     * 
     * @type {Array<OmimGeneSet>}
     * @memberof VariantOverview
     */
    'omim_conditions'?: Array<OmimGeneSet>;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'pc'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'pf': number;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'phyloP17way_primate'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantOverview
     */
    'picked_consequences': Array<string>;
    /**
     * TODO
     * @type {number}
     * @memberof VariantOverview
     */
    'pn'?: number;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'polyphen2_hvar_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'polyphen2_hvar_score'?: number;
    /**
     * TODO
     * @type {string}
     * @memberof VariantOverview
     */
    'refseq_mrna_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'revel_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'rsnumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'sift_pred'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'sift_score'?: number;
    /**
     * TODO
     * @type {Array<string>}
     * @memberof VariantOverview
     */
    'source'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof VariantOverview
     */
    'spliceai_ds'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantOverview
     */
    'spliceai_type'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariantOverview
     */
    'transcript_id'?: string;
}

/**
 * HpoApi - axios parameter creator
 * @export
 */
export const HpoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve AutoCompleteTerm list of HPO terms matching input string with highlighted
         * @summary Get AutoCompleteTerm list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hpoTermAutoComplete: async (prefix: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prefix' is not null or undefined
            assertParamExists('hpoTermAutoComplete', 'prefix', prefix)
            const localVarPath = `/hpo/autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HpoApi - functional programming interface
 * @export
 */
export const HpoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HpoApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve AutoCompleteTerm list of HPO terms matching input string with highlighted
         * @summary Get AutoCompleteTerm list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hpoTermAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutoCompleteTerm>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hpoTermAutoComplete(prefix, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HpoApi.hpoTermAutoComplete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HpoApi - factory interface
 * @export
 */
export const HpoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HpoApiFp(configuration)
    return {
        /**
         * Retrieve AutoCompleteTerm list of HPO terms matching input string with highlighted
         * @summary Get AutoCompleteTerm list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hpoTermAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AutoCompleteTerm>> {
            return localVarFp.hpoTermAutoComplete(prefix, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HpoApi - object-oriented interface
 * @export
 * @class HpoApi
 * @extends {BaseAPI}
 */
export class HpoApi extends BaseAPI {
    /**
     * Retrieve AutoCompleteTerm list of HPO terms matching input string with highlighted
     * @summary Get AutoCompleteTerm list of matching input string with highlighted
     * @param {string} prefix Prefix
     * @param {string} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HpoApi
     */
    public hpoTermAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig) {
        return HpoApiFp(this.configuration).hpoTermAutoComplete(prefix, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InterpretationsApi - axios parameter creator
 * @export
 */
export const InterpretationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get interpretation germline
         * @summary Get interpretation germline
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterpretationGermline: async (sequencingId: string, locusId: string, transcriptId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequencingId' is not null or undefined
            assertParamExists('getInterpretationGermline', 'sequencingId', sequencingId)
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getInterpretationGermline', 'locusId', locusId)
            // verify required parameter 'transcriptId' is not null or undefined
            assertParamExists('getInterpretationGermline', 'transcriptId', transcriptId)
            const localVarPath = `/interpretations/germline/{sequencing_id}/{locus_id}/{transcript_id}`
                .replace(`{${"sequencing_id"}}`, encodeURIComponent(String(sequencingId)))
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"transcript_id"}}`, encodeURIComponent(String(transcriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get interpretation somatic
         * @summary Get interpretation somatic
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterpretationSomatic: async (sequencingId: string, locusId: string, transcriptId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequencingId' is not null or undefined
            assertParamExists('getInterpretationSomatic', 'sequencingId', sequencingId)
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getInterpretationSomatic', 'locusId', locusId)
            // verify required parameter 'transcriptId' is not null or undefined
            assertParamExists('getInterpretationSomatic', 'transcriptId', transcriptId)
            const localVarPath = `/interpretations/somatic/{sequencing_id}/{locus_id}/{transcript_id}`
                .replace(`{${"sequencing_id"}}`, encodeURIComponent(String(sequencingId)))
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"transcript_id"}}`, encodeURIComponent(String(transcriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get pubmed citation by ID
         * @summary Get pubmed citation by ID
         * @param {string} citationId Citation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPubmedCitation: async (citationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'citationId' is not null or undefined
            assertParamExists('getPubmedCitation', 'citationId', citationId)
            const localVarPath = `/interpretations/pubmed/{citation_id}`
                .replace(`{${"citation_id"}}`, encodeURIComponent(String(citationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or Update interpretation germline
         * @summary Create or Update interpretation germline
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationGermline} interpretationGermline Interpretation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInterpretationGermline: async (sequencingId: string, locusId: string, transcriptId: string, interpretationGermline: InterpretationGermline, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequencingId' is not null or undefined
            assertParamExists('postInterpretationGermline', 'sequencingId', sequencingId)
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('postInterpretationGermline', 'locusId', locusId)
            // verify required parameter 'transcriptId' is not null or undefined
            assertParamExists('postInterpretationGermline', 'transcriptId', transcriptId)
            // verify required parameter 'interpretationGermline' is not null or undefined
            assertParamExists('postInterpretationGermline', 'interpretationGermline', interpretationGermline)
            const localVarPath = `/interpretations/germline/{sequencing_id}/{locus_id}/{transcript_id}`
                .replace(`{${"sequencing_id"}}`, encodeURIComponent(String(sequencingId)))
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"transcript_id"}}`, encodeURIComponent(String(transcriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(interpretationGermline, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or Update interpretation somatic
         * @summary Create or Update interpretation somatic
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationSomatic} interpretationSomatic Interpretation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInterpretationSomatic: async (sequencingId: string, locusId: string, transcriptId: string, interpretationSomatic: InterpretationSomatic, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequencingId' is not null or undefined
            assertParamExists('postInterpretationSomatic', 'sequencingId', sequencingId)
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('postInterpretationSomatic', 'locusId', locusId)
            // verify required parameter 'transcriptId' is not null or undefined
            assertParamExists('postInterpretationSomatic', 'transcriptId', transcriptId)
            // verify required parameter 'interpretationSomatic' is not null or undefined
            assertParamExists('postInterpretationSomatic', 'interpretationSomatic', interpretationSomatic)
            const localVarPath = `/interpretations/somatic/{sequencing_id}/{locus_id}/{transcript_id}`
                .replace(`{${"sequencing_id"}}`, encodeURIComponent(String(sequencingId)))
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)))
                .replace(`{${"transcript_id"}}`, encodeURIComponent(String(transcriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(interpretationSomatic, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search interpretation germline
         * @summary Search interpretation germline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInterpretationGermline: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/interpretations/germline`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search interpretation somatic
         * @summary Search interpretation somatic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInterpretationSomatic: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/interpretations/somatic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InterpretationsApi - functional programming interface
 * @export
 */
export const InterpretationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InterpretationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get interpretation germline
         * @summary Get interpretation germline
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInterpretationGermline(sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterpretationGermline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInterpretationGermline(sequencingId, locusId, transcriptId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.getInterpretationGermline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get interpretation somatic
         * @summary Get interpretation somatic
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInterpretationSomatic(sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterpretationSomatic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInterpretationSomatic(sequencingId, locusId, transcriptId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.getInterpretationSomatic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get pubmed citation by ID
         * @summary Get pubmed citation by ID
         * @param {string} citationId Citation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPubmedCitation(citationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PubmedCitation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPubmedCitation(citationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.getPubmedCitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or Update interpretation germline
         * @summary Create or Update interpretation germline
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationGermline} interpretationGermline Interpretation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postInterpretationGermline(sequencingId: string, locusId: string, transcriptId: string, interpretationGermline: InterpretationGermline, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterpretationGermline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postInterpretationGermline(sequencingId, locusId, transcriptId, interpretationGermline, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.postInterpretationGermline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or Update interpretation somatic
         * @summary Create or Update interpretation somatic
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationSomatic} interpretationSomatic Interpretation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postInterpretationSomatic(sequencingId: string, locusId: string, transcriptId: string, interpretationSomatic: InterpretationSomatic, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterpretationSomatic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postInterpretationSomatic(sequencingId, locusId, transcriptId, interpretationSomatic, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.postInterpretationSomatic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search interpretation germline
         * @summary Search interpretation germline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchInterpretationGermline(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchInterpretationGermline(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.searchInterpretationGermline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search interpretation somatic
         * @summary Search interpretation somatic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchInterpretationSomatic(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InterpretationSomatic>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchInterpretationSomatic(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InterpretationsApi.searchInterpretationSomatic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InterpretationsApi - factory interface
 * @export
 */
export const InterpretationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InterpretationsApiFp(configuration)
    return {
        /**
         * Get interpretation germline
         * @summary Get interpretation germline
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterpretationGermline(sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig): AxiosPromise<InterpretationGermline> {
            return localVarFp.getInterpretationGermline(sequencingId, locusId, transcriptId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get interpretation somatic
         * @summary Get interpretation somatic
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterpretationSomatic(sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig): AxiosPromise<InterpretationSomatic> {
            return localVarFp.getInterpretationSomatic(sequencingId, locusId, transcriptId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get pubmed citation by ID
         * @summary Get pubmed citation by ID
         * @param {string} citationId Citation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPubmedCitation(citationId: string, options?: RawAxiosRequestConfig): AxiosPromise<PubmedCitation> {
            return localVarFp.getPubmedCitation(citationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or Update interpretation germline
         * @summary Create or Update interpretation germline
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationGermline} interpretationGermline Interpretation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInterpretationGermline(sequencingId: string, locusId: string, transcriptId: string, interpretationGermline: InterpretationGermline, options?: RawAxiosRequestConfig): AxiosPromise<InterpretationGermline> {
            return localVarFp.postInterpretationGermline(sequencingId, locusId, transcriptId, interpretationGermline, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or Update interpretation somatic
         * @summary Create or Update interpretation somatic
         * @param {string} sequencingId Sequencing ID
         * @param {string} locusId Locus ID
         * @param {string} transcriptId Transcript ID
         * @param {InterpretationSomatic} interpretationSomatic Interpretation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInterpretationSomatic(sequencingId: string, locusId: string, transcriptId: string, interpretationSomatic: InterpretationSomatic, options?: RawAxiosRequestConfig): AxiosPromise<InterpretationSomatic> {
            return localVarFp.postInterpretationSomatic(sequencingId, locusId, transcriptId, interpretationSomatic, options).then((request) => request(axios, basePath));
        },
        /**
         * Search interpretation germline
         * @summary Search interpretation germline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInterpretationGermline(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.searchInterpretationGermline(options).then((request) => request(axios, basePath));
        },
        /**
         * Search interpretation somatic
         * @summary Search interpretation somatic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInterpretationSomatic(options?: RawAxiosRequestConfig): AxiosPromise<Array<InterpretationSomatic>> {
            return localVarFp.searchInterpretationSomatic(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InterpretationsApi - object-oriented interface
 * @export
 * @class InterpretationsApi
 * @extends {BaseAPI}
 */
export class InterpretationsApi extends BaseAPI {
    /**
     * Get interpretation germline
     * @summary Get interpretation germline
     * @param {string} sequencingId Sequencing ID
     * @param {string} locusId Locus ID
     * @param {string} transcriptId Transcript ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public getInterpretationGermline(sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).getInterpretationGermline(sequencingId, locusId, transcriptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get interpretation somatic
     * @summary Get interpretation somatic
     * @param {string} sequencingId Sequencing ID
     * @param {string} locusId Locus ID
     * @param {string} transcriptId Transcript ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public getInterpretationSomatic(sequencingId: string, locusId: string, transcriptId: string, options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).getInterpretationSomatic(sequencingId, locusId, transcriptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get pubmed citation by ID
     * @summary Get pubmed citation by ID
     * @param {string} citationId Citation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public getPubmedCitation(citationId: string, options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).getPubmedCitation(citationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or Update interpretation germline
     * @summary Create or Update interpretation germline
     * @param {string} sequencingId Sequencing ID
     * @param {string} locusId Locus ID
     * @param {string} transcriptId Transcript ID
     * @param {InterpretationGermline} interpretationGermline Interpretation Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public postInterpretationGermline(sequencingId: string, locusId: string, transcriptId: string, interpretationGermline: InterpretationGermline, options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).postInterpretationGermline(sequencingId, locusId, transcriptId, interpretationGermline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or Update interpretation somatic
     * @summary Create or Update interpretation somatic
     * @param {string} sequencingId Sequencing ID
     * @param {string} locusId Locus ID
     * @param {string} transcriptId Transcript ID
     * @param {InterpretationSomatic} interpretationSomatic Interpretation Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public postInterpretationSomatic(sequencingId: string, locusId: string, transcriptId: string, interpretationSomatic: InterpretationSomatic, options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).postInterpretationSomatic(sequencingId, locusId, transcriptId, interpretationSomatic, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search interpretation germline
     * @summary Search interpretation germline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public searchInterpretationGermline(options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).searchInterpretationGermline(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search interpretation somatic
     * @summary Search interpretation somatic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterpretationsApi
     */
    public searchInterpretationSomatic(options?: RawAxiosRequestConfig) {
        return InterpretationsApiFp(this.configuration).searchInterpretationSomatic(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MondoApi - axios parameter creator
 * @export
 */
export const MondoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve AutoCompleteTerm list of mondo terms matching input string with highlighted
         * @summary Get AutoCompleteTerm list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mondoTermAutoComplete: async (prefix: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prefix' is not null or undefined
            assertParamExists('mondoTermAutoComplete', 'prefix', prefix)
            const localVarPath = `/mondo/autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MondoApi - functional programming interface
 * @export
 */
export const MondoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MondoApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve AutoCompleteTerm list of mondo terms matching input string with highlighted
         * @summary Get AutoCompleteTerm list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mondoTermAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutoCompleteTerm>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mondoTermAutoComplete(prefix, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MondoApi.mondoTermAutoComplete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MondoApi - factory interface
 * @export
 */
export const MondoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MondoApiFp(configuration)
    return {
        /**
         * Retrieve AutoCompleteTerm list of mondo terms matching input string with highlighted
         * @summary Get AutoCompleteTerm list of matching input string with highlighted
         * @param {string} prefix Prefix
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mondoTermAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AutoCompleteTerm>> {
            return localVarFp.mondoTermAutoComplete(prefix, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MondoApi - object-oriented interface
 * @export
 * @class MondoApi
 * @extends {BaseAPI}
 */
export class MondoApi extends BaseAPI {
    /**
     * Retrieve AutoCompleteTerm list of mondo terms matching input string with highlighted
     * @summary Get AutoCompleteTerm list of matching input string with highlighted
     * @param {string} prefix Prefix
     * @param {string} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MondoApi
     */
    public mondoTermAutoComplete(prefix: string, limit?: string, options?: RawAxiosRequestConfig) {
        return MondoApiFp(this.configuration).mondoTermAutoComplete(prefix, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OccurrencesApi - axios parameter creator
 * @export
 */
export const OccurrencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Aggregate occurrences for a given sequence ID
         * @summary Aggregate occurrences
         * @param {string} seqId Sequence ID
         * @param {AggregationBody} aggregationBody Aggregation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregateOccurrences: async (seqId: string, aggregationBody: AggregationBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('aggregateOccurrences', 'seqId', seqId)
            // verify required parameter 'aggregationBody' is not null or undefined
            assertParamExists('aggregateOccurrences', 'aggregationBody', aggregationBody)
            const localVarPath = `/occurrences/{seq_id}/aggregate`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aggregationBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Counts occurrences for a given sequence ID
         * @summary Count occurrences
         * @param {string} seqId Sequence ID
         * @param {CountBody} countBody Count Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countOccurrences: async (seqId: string, countBody: CountBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('countOccurrences', 'seqId', seqId)
            // verify required parameter 'countBody' is not null or undefined
            assertParamExists('countOccurrences', 'countBody', countBody)
            const localVarPath = `/occurrences/{seq_id}/count`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(countBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve ExpendedOccurrence data for a given locus ID
         * @summary Get a ExpendedOccurrence
         * @param {string} seqId Sequence ID
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpendedOccurrence: async (seqId: string, locusId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('getExpendedOccurrence', 'seqId', seqId)
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getExpendedOccurrence', 'locusId', locusId)
            const localVarPath = `/occurrences/{seq_id}/{locus_id}/expended`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)))
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List occurrences for a given sequence ID
         * @summary List occurrences
         * @param {string} seqId Sequence ID
         * @param {ListBody} listBody List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOccurrences: async (seqId: string, listBody: ListBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('listOccurrences', 'seqId', seqId)
            // verify required parameter 'listBody' is not null or undefined
            assertParamExists('listOccurrences', 'listBody', listBody)
            const localVarPath = `/occurrences/{seq_id}/list`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return statistics about a field for a given sequence ID
         * @summary Statistics of occurrences
         * @param {string} seqId Sequence ID
         * @param {StatisticsBody} statisticsBody Statistics Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsOccurrences: async (seqId: string, statisticsBody: StatisticsBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('statisticsOccurrences', 'seqId', seqId)
            // verify required parameter 'statisticsBody' is not null or undefined
            assertParamExists('statisticsOccurrences', 'statisticsBody', statisticsBody)
            const localVarPath = `/occurrences/{seq_id}/statistics`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(statisticsBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OccurrencesApi - functional programming interface
 * @export
 */
export const OccurrencesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OccurrencesApiAxiosParamCreator(configuration)
    return {
        /**
         * Aggregate occurrences for a given sequence ID
         * @summary Aggregate occurrences
         * @param {string} seqId Sequence ID
         * @param {AggregationBody} aggregationBody Aggregation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aggregateOccurrences(seqId: string, aggregationBody: AggregationBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Aggregation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aggregateOccurrences(seqId, aggregationBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.aggregateOccurrences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Counts occurrences for a given sequence ID
         * @summary Count occurrences
         * @param {string} seqId Sequence ID
         * @param {CountBody} countBody Count Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countOccurrences(seqId: string, countBody: CountBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Count>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countOccurrences(seqId, countBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.countOccurrences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve ExpendedOccurrence data for a given locus ID
         * @summary Get a ExpendedOccurrence
         * @param {string} seqId Sequence ID
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExpendedOccurrence(seqId: string, locusId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpendedOccurrence>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExpendedOccurrence(seqId, locusId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.getExpendedOccurrence']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List occurrences for a given sequence ID
         * @summary List occurrences
         * @param {string} seqId Sequence ID
         * @param {ListBody} listBody List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOccurrences(seqId: string, listBody: ListBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Occurrence>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOccurrences(seqId, listBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.listOccurrences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return statistics about a field for a given sequence ID
         * @summary Statistics of occurrences
         * @param {string} seqId Sequence ID
         * @param {StatisticsBody} statisticsBody Statistics Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statisticsOccurrences(seqId: string, statisticsBody: StatisticsBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Statistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statisticsOccurrences(seqId, statisticsBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.statisticsOccurrences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OccurrencesApi - factory interface
 * @export
 */
export const OccurrencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OccurrencesApiFp(configuration)
    return {
        /**
         * Aggregate occurrences for a given sequence ID
         * @summary Aggregate occurrences
         * @param {string} seqId Sequence ID
         * @param {AggregationBody} aggregationBody Aggregation Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregateOccurrences(seqId: string, aggregationBody: AggregationBody, options?: RawAxiosRequestConfig): AxiosPromise<Array<Aggregation>> {
            return localVarFp.aggregateOccurrences(seqId, aggregationBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Counts occurrences for a given sequence ID
         * @summary Count occurrences
         * @param {string} seqId Sequence ID
         * @param {CountBody} countBody Count Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countOccurrences(seqId: string, countBody: CountBody, options?: RawAxiosRequestConfig): AxiosPromise<Count> {
            return localVarFp.countOccurrences(seqId, countBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve ExpendedOccurrence data for a given locus ID
         * @summary Get a ExpendedOccurrence
         * @param {string} seqId Sequence ID
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpendedOccurrence(seqId: string, locusId: string, options?: RawAxiosRequestConfig): AxiosPromise<ExpendedOccurrence> {
            return localVarFp.getExpendedOccurrence(seqId, locusId, options).then((request) => request(axios, basePath));
        },
        /**
         * List occurrences for a given sequence ID
         * @summary List occurrences
         * @param {string} seqId Sequence ID
         * @param {ListBody} listBody List Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOccurrences(seqId: string, listBody: ListBody, options?: RawAxiosRequestConfig): AxiosPromise<Array<Occurrence>> {
            return localVarFp.listOccurrences(seqId, listBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Return statistics about a field for a given sequence ID
         * @summary Statistics of occurrences
         * @param {string} seqId Sequence ID
         * @param {StatisticsBody} statisticsBody Statistics Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsOccurrences(seqId: string, statisticsBody: StatisticsBody, options?: RawAxiosRequestConfig): AxiosPromise<Statistics> {
            return localVarFp.statisticsOccurrences(seqId, statisticsBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OccurrencesApi - object-oriented interface
 * @export
 * @class OccurrencesApi
 * @extends {BaseAPI}
 */
export class OccurrencesApi extends BaseAPI {
    /**
     * Aggregate occurrences for a given sequence ID
     * @summary Aggregate occurrences
     * @param {string} seqId Sequence ID
     * @param {AggregationBody} aggregationBody Aggregation Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public aggregateOccurrences(seqId: string, aggregationBody: AggregationBody, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).aggregateOccurrences(seqId, aggregationBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Counts occurrences for a given sequence ID
     * @summary Count occurrences
     * @param {string} seqId Sequence ID
     * @param {CountBody} countBody Count Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public countOccurrences(seqId: string, countBody: CountBody, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).countOccurrences(seqId, countBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve ExpendedOccurrence data for a given locus ID
     * @summary Get a ExpendedOccurrence
     * @param {string} seqId Sequence ID
     * @param {string} locusId Locus ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public getExpendedOccurrence(seqId: string, locusId: string, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).getExpendedOccurrence(seqId, locusId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List occurrences for a given sequence ID
     * @summary List occurrences
     * @param {string} seqId Sequence ID
     * @param {ListBody} listBody List Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public listOccurrences(seqId: string, listBody: ListBody, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).listOccurrences(seqId, listBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return statistics about a field for a given sequence ID
     * @summary Statistics of occurrences
     * @param {string} seqId Sequence ID
     * @param {StatisticsBody} statisticsBody Statistics Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public statisticsOccurrences(seqId: string, statisticsBody: StatisticsBody, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).statisticsOccurrences(seqId, statisticsBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SequencingApi - axios parameter creator
 * @export
 */
export const SequencingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve Sequencing data for a given sequence ID
         * @summary Get a Sequencing
         * @param {string} seqId Sequence ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSequencing: async (seqId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seqId' is not null or undefined
            assertParamExists('getSequencing', 'seqId', seqId)
            const localVarPath = `/sequencing/{seq_id}`
                .replace(`{${"seq_id"}}`, encodeURIComponent(String(seqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SequencingApi - functional programming interface
 * @export
 */
export const SequencingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SequencingApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve Sequencing data for a given sequence ID
         * @summary Get a Sequencing
         * @param {string} seqId Sequence ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSequencing(seqId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sequencing>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSequencing(seqId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SequencingApi.getSequencing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SequencingApi - factory interface
 * @export
 */
export const SequencingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SequencingApiFp(configuration)
    return {
        /**
         * Retrieve Sequencing data for a given sequence ID
         * @summary Get a Sequencing
         * @param {string} seqId Sequence ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSequencing(seqId: string, options?: RawAxiosRequestConfig): AxiosPromise<Sequencing> {
            return localVarFp.getSequencing(seqId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SequencingApi - object-oriented interface
 * @export
 * @class SequencingApi
 * @extends {BaseAPI}
 */
export class SequencingApi extends BaseAPI {
    /**
     * Retrieve Sequencing data for a given sequence ID
     * @summary Get a Sequencing
     * @param {string} seqId Sequence ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SequencingApi
     */
    public getSequencing(seqId: string, options?: RawAxiosRequestConfig) {
        return SequencingApiFp(this.configuration).getSequencing(seqId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the current status of the API
         * @summary Get API status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatusApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the current status of the API
         * @summary Get API status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusApi.statusGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatusApiFp(configuration)
    return {
        /**
         * Returns the current status of the API
         * @summary Get API status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGet(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.statusGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
    /**
     * Returns the current status of the API
     * @summary Get API status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public statusGet(options?: RawAxiosRequestConfig) {
        return StatusApiFp(this.configuration).statusGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserSetsApi - axios parameter creator
 * @export
 */
export const UserSetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get user set
         * @summary Get user set by id
         * @param {string} userSetId UserSet ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSet: async (userSetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userSetId' is not null or undefined
            assertParamExists('getUserSet', 'userSetId', userSetId)
            const localVarPath = `/users/sets/{user_set_id}`
                .replace(`{${"user_set_id"}}`, encodeURIComponent(String(userSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserSetsApi - functional programming interface
 * @export
 */
export const UserSetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserSetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get user set
         * @summary Get user set by id
         * @param {string} userSetId UserSet ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserSet(userSetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserSet(userSetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserSetsApi.getUserSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserSetsApi - factory interface
 * @export
 */
export const UserSetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserSetsApiFp(configuration)
    return {
        /**
         * Get user set
         * @summary Get user set by id
         * @param {string} userSetId UserSet ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSet(userSetId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserSet> {
            return localVarFp.getUserSet(userSetId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserSetsApi - object-oriented interface
 * @export
 * @class UserSetsApi
 * @extends {BaseAPI}
 */
export class UserSetsApi extends BaseAPI {
    /**
     * Get user set
     * @summary Get user set by id
     * @param {string} userSetId UserSet ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSetsApi
     */
    public getUserSet(userSetId: string, options?: RawAxiosRequestConfig) {
        return UserSetsApiFp(this.configuration).getUserSet(userSetId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VariantApi - axios parameter creator
 * @export
 */
export const VariantApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve Variant Overview data for a given locus
         * @summary Get a VariantOverview
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariantOverview: async (locusId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locusId' is not null or undefined
            assertParamExists('getVariantOverview', 'locusId', locusId)
            const localVarPath = `/variants/{locus_id}/overview`
                .replace(`{${"locus_id"}}`, encodeURIComponent(String(locusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VariantApi - functional programming interface
 * @export
 */
export const VariantApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VariantApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve Variant Overview data for a given locus
         * @summary Get a VariantOverview
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVariantOverview(locusId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantOverview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVariantOverview(locusId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariantApi.getVariantOverview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VariantApi - factory interface
 * @export
 */
export const VariantApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VariantApiFp(configuration)
    return {
        /**
         * Retrieve Variant Overview data for a given locus
         * @summary Get a VariantOverview
         * @param {string} locusId Locus ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariantOverview(locusId: string, options?: RawAxiosRequestConfig): AxiosPromise<VariantOverview> {
            return localVarFp.getVariantOverview(locusId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VariantApi - object-oriented interface
 * @export
 * @class VariantApi
 * @extends {BaseAPI}
 */
export class VariantApi extends BaseAPI {
    /**
     * Retrieve Variant Overview data for a given locus
     * @summary Get a VariantOverview
     * @param {string} locusId Locus ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariantApi
     */
    public getVariantOverview(locusId: string, options?: RawAxiosRequestConfig) {
        return VariantApiFp(this.configuration).getVariantOverview(locusId, options).then((request) => request(this.axios, this.basePath));
    }
}



