import{r as y,R as Ct}from"./index-tvICUrOf.js";import{r as ae}from"./index-yBjzXJbu.js";import{a as Jt,H as ce,O as ue,B as bt,I as le,b as fe}from"./query-builder-remote-CzQy3Xv-.js";var ft={exports:{}},dt={};/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Ut;function de(){if(Ut)return dt;Ut=1;var t=ae();function e(a,l){return a===l&&(a!==0||1/a===1/l)||a!==a&&l!==l}var n=typeof Object.is=="function"?Object.is:e,s=t.useState,u=t.useEffect,r=t.useLayoutEffect,i=t.useDebugValue;function E(a,l){var f=l(),D=s({inst:{value:f,getSnapshot:l}}),d=D[0].inst,q=D[1];return r(function(){d.value=f,d.getSnapshot=l,R(d)&&q({inst:d})},[a,f,l]),u(function(){return R(d)&&q({inst:d}),a(function(){R(d)&&q({inst:d})})},[a]),i(f),f}function R(a){var l=a.getSnapshot;a=a.value;try{var f=l();return!n(a,f)}catch{return!0}}function C(a,l){return l()}var m=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?C:E;return dt.useSyncExternalStore=t.useSyncExternalStore!==void 0?t.useSyncExternalStore:m,dt}var Ht;function he(){return Ht||(Ht=1,ft.exports=de()),ft.exports}var pe=he();const Gt=0,Yt=1,Xt=2,kt=3;var $t=Object.prototype.hasOwnProperty;function mt(t,e){var n,s;if(t===e)return!0;if(t&&e&&(n=t.constructor)===e.constructor){if(n===Date)return t.getTime()===e.getTime();if(n===RegExp)return t.toString()===e.toString();if(n===Array){if((s=t.length)===e.length)for(;s--&&mt(t[s],e[s]););return s===-1}if(!n||typeof t=="object"){s=0;for(n in t)if($t.call(t,n)&&++s&&!$t.call(e,n)||!(n in e)||!mt(t[n],e[n]))return!1;return Object.keys(e).length===s}}return t!==t&&e!==e}const N=new WeakMap,M=()=>{},_=M(),vt=Object,c=t=>t===_,V=t=>typeof t=="function",W=(t,e)=>({...t,...e}),Qt=t=>V(t.then),ht={},it={},At="undefined",et=typeof window!=At,gt=typeof document!=At,Ee=et&&"Deno"in window,Re=()=>et&&typeof window.requestAnimationFrame!=At,Zt=(t,e)=>{const n=N.get(t);return[()=>!c(e)&&t.get(e)||ht,s=>{if(!c(e)){const u=t.get(e);e in it||(it[e]=u),n[5](e,W(u,s),u||ht)}},n[6],()=>!c(e)&&e in it?it[e]:!c(e)&&t.get(e)||ht]};let Ot=!0;const Se=()=>Ot,[yt,Tt]=et&&window.addEventListener?[window.addEventListener.bind(window),window.removeEventListener.bind(window)]:[M,M],we=()=>{const t=gt&&document.visibilityState;return c(t)||t!=="hidden"},me=t=>(gt&&document.addEventListener("visibilitychange",t),yt("focus",t),()=>{gt&&document.removeEventListener("visibilitychange",t),Tt("focus",t)}),ve=t=>{const e=()=>{Ot=!0,t()},n=()=>{Ot=!1};return yt("online",e),yt("offline",n),()=>{Tt("online",e),Tt("offline",n)}},ge={isOnline:Se,isVisible:we},Oe={initFocus:me,initReconnect:ve},Bt=!Ct.useId,tt=!et||Ee,ye=t=>Re()?window.requestAnimationFrame(t):setTimeout(t,1),pt=tt?y.useEffect:y.useLayoutEffect,Et=typeof navigator<"u"&&navigator.connection,Kt=!tt&&Et&&(["slow-2g","2g"].includes(Et.effectiveType)||Et.saveData),at=new WeakMap,Rt=(t,e)=>vt.prototype.toString.call(t)===`[object ${e}]`;let Te=0;const _t=t=>{const e=typeof t,n=Rt(t,"Date"),s=Rt(t,"RegExp"),u=Rt(t,"Object");let r,i;if(vt(t)===t&&!n&&!s){if(r=at.get(t),r)return r;if(r=++Te+"~",at.set(t,r),Array.isArray(t)){for(r="@",i=0;i<t.length;i++)r+=_t(t[i])+",";at.set(t,r)}if(u){r="#";const E=vt.keys(t).sort();for(;!c(i=E.pop());)c(t[i])||(r+=i+":"+_t(t[i])+",");at.set(t,r)}}else r=n?t.toJSON():e=="symbol"?t.toString():e=="string"?JSON.stringify(t):""+t;return r},It=t=>{if(V(t))try{t=t()}catch{t=""}const e=t;return t=typeof t=="string"?t:(Array.isArray(t)?t.length:t)?_t(t):"",[t,e]};let _e=0;const Dt=()=>++_e;async function te(...t){const[e,n,s,u]=t,r=W({populateCache:!0,throwOnError:!0},typeof u=="boolean"?{revalidate:u}:u||{});let i=r.populateCache;const E=r.rollbackOnError;let R=r.optimisticData;const C=l=>typeof E=="function"?E(l):E!==!1,m=r.throwOnError;if(V(n)){const l=n,f=[],D=e.keys();for(const d of D)!/^\$(inf|sub)\$/.test(d)&&l(e.get(d)._k)&&f.push(d);return Promise.all(f.map(a))}return a(n);async function a(l){const[f]=It(l);if(!f)return;const[D,d]=Zt(e,f),[q,o,nt,X]=N.get(e),F=()=>{const I=q[f];return(V(r.revalidate)?r.revalidate(D().data,l):r.revalidate!==!1)&&(delete nt[f],delete X[f],I&&I[0])?I[0](Xt).then(()=>D().data):D().data};if(t.length<3)return F();let g=s,b;const k=Dt();o[f]=[k,0];const S=!c(R),$=D(),x=$.data,B=$._c,U=c(B)?x:B;if(S&&(R=V(R)?R(U,x):R,d({data:R,_c:U})),V(g))try{g=g(U)}catch(I){b=I}if(g&&Qt(g))if(g=await g.catch(I=>{b=I}),k!==o[f][0]){if(b)throw b;return g}else b&&S&&C(b)&&(i=!0,d({data:U,_c:_}));if(i&&!b)if(V(i)){const I=i(g,U);d({data:I,error:_,_c:_})}else d({data:g,error:_,_c:_});if(o[f][1]=Dt(),Promise.resolve(F()).then(()=>{d({_c:_})}),b){if(m)throw b;return}return g}}const zt=(t,e)=>{for(const n in t)t[n][0]&&t[n][0](e)},De=(t,e)=>{if(!N.has(t)){const n=W(Oe,e),s=Object.create(null),u=te.bind(_,t);let r=M;const i=Object.create(null),E=(m,a)=>{const l=i[m]||[];return i[m]=l,l.push(a),()=>l.splice(l.indexOf(a),1)},R=(m,a,l)=>{t.set(m,a);const f=i[m];if(f)for(const D of f)D(a,l)},C=()=>{if(!N.has(t)&&(N.set(t,[s,Object.create(null),Object.create(null),Object.create(null),u,R,E]),!tt)){const m=n.initFocus(setTimeout.bind(_,zt.bind(_,s,Gt))),a=n.initReconnect(setTimeout.bind(_,zt.bind(_,s,Yt)));r=()=>{m&&m(),a&&a(),N.delete(t)}}};return C(),[t,u,C,r]}return[t,N.get(t)[4]]},Ce=(t,e,n,s,u)=>{const r=n.errorRetryCount,i=u.retryCount,E=~~((Math.random()+.5)*(1<<(i<8?i:8)))*n.errorRetryInterval;!c(r)&&i>r||setTimeout(s,E,u)},be=mt,[ee,Ae]=De(new Map),Ie=W({onLoadingSlow:M,onSuccess:M,onError:M,onErrorRetry:Ce,onDiscarded:M,revalidateOnFocus:!0,revalidateOnReconnect:!0,revalidateIfStale:!0,shouldRetryOnError:!0,errorRetryInterval:Kt?1e4:5e3,focusThrottleInterval:5*1e3,dedupingInterval:2*1e3,loadingTimeout:Kt?5e3:3e3,compare:be,isPaused:()=>!1,cache:ee,mutate:Ae,fallback:{}},ge),Le=(t,e)=>{const n=W(t,e);if(e){const{use:s,fallback:u}=t,{use:r,fallback:i}=e;s&&r&&(n.use=s.concat(r)),u&&i&&(n.fallback=W(u,i))}return n},xe=y.createContext({}),Ve="$inf$",ne=et&&window.__SWR_DEVTOOLS_USE__,je=ne?window.__SWR_DEVTOOLS_USE__:[],Pe=()=>{ne&&(window.__SWR_DEVTOOLS_REACT__=Ct)},Ne=t=>V(t[1])?[t[0],t[1],t[2]||{}]:[t[0],null,(t[1]===null?t[2]:t[1])||{}],Fe=()=>W(Ie,y.useContext(xe)),Me=t=>(e,n,s)=>t(e,n&&((...r)=>{const[i]=It(e),[,,,E]=N.get(ee);if(i.startsWith(Ve))return n(...r);const R=E[i];return c(R)?n(...r):(delete E[i],R)}),s),We=je.concat(Me),qe=t=>function(...n){const s=Fe(),[u,r,i]=Ne(n),E=Le(s,i);let R=t;const{use:C}=E,m=(C||[]).concat(We);for(let a=m.length;a--;)R=m[a](R);return R(u,r||E.fetcher||null,E)},Ue=(t,e,n)=>{const s=e[t]||(e[t]=[]);return s.push(n),()=>{const u=s.indexOf(n);u>=0&&(s[u]=s[s.length-1],s.pop())}};Pe();const St=Ct.use||(t=>{switch(t.status){case"pending":throw t;case"fulfilled":return t.value;case"rejected":throw t.reason;default:throw t.status="pending",t.then(e=>{t.status="fulfilled",t.value=e},e=>{t.status="rejected",t.reason=e}),t}}),wt={dedupe:!0},He=(t,e,n)=>{const{cache:s,compare:u,suspense:r,fallbackData:i,revalidateOnMount:E,revalidateIfStale:R,refreshInterval:C,refreshWhenHidden:m,refreshWhenOffline:a,keepPreviousData:l}=n,[f,D,d,q]=N.get(s),[o,nt]=It(t),X=y.useRef(!1),F=y.useRef(!1),g=y.useRef(o),b=y.useRef(e),k=y.useRef(n),S=()=>k.current,$=()=>S().isVisible()&&S().isOnline(),[x,B,U,I]=Zt(s,o),K=y.useRef({}).current,st=c(i)?c(n.fallback)?_:n.fallback[o]:i,xt=(p,h)=>{for(const O in K){const w=O;if(w==="data"){if(!u(p[w],h[w])&&(!c(p[w])||!u(ot,h[w])))return!1}else if(h[w]!==p[w])return!1}return!0},Vt=y.useMemo(()=>{const p=!o||!e?!1:c(E)?S().isPaused()||r?!1:R!==!1:E,h=T=>{const j=W(T);return delete j._k,p?{isValidating:!0,isLoading:!0,...j}:j},O=x(),w=I(),L=h(O),G=O===w?L:h(w);let v=L;return[()=>{const T=h(x());return xt(T,v)?(v.data=T.data,v.isLoading=T.isLoading,v.isValidating=T.isValidating,v.error=T.error,v):(v=T,T)},()=>G]},[s,o]),z=pe.useSyncExternalStore(y.useCallback(p=>U(o,(h,O)=>{xt(O,h)||p()}),[s,o]),Vt[0],Vt[1]),jt=!X.current,se=f[o]&&f[o].length>0,J=z.data,H=c(J)?st&&Qt(st)?St(st):st:J,rt=z.error,ct=y.useRef(H),ot=l?c(J)?c(ct.current)?H:ct.current:J:H,Pt=se&&!c(rt)?!1:jt&&!c(E)?E:S().isPaused()?!1:r?c(H)?!1:R:c(H)||R,Nt=!!(o&&e&&jt&&Pt),re=c(z.isValidating)?Nt:z.isValidating,oe=c(z.isLoading)?Nt:z.isLoading,Q=y.useCallback(async p=>{const h=b.current;if(!o||!h||F.current||S().isPaused())return!1;let O,w,L=!0;const G=p||{},v=!d[o]||!G.dedupe,T=()=>Bt?!F.current&&o===g.current&&X.current:o===g.current,j={isValidating:!1,isLoading:!1},Mt=()=>{B(j)},Wt=()=>{const A=d[o];A&&A[1]===w&&delete d[o]},qt={isValidating:!0};c(x().data)&&(qt.isLoading=!0);try{if(v&&(B(qt),n.loadingTimeout&&c(x().data)&&setTimeout(()=>{L&&T()&&S().onLoadingSlow(o,n)},n.loadingTimeout),d[o]=[h(nt),Dt()]),[O,w]=d[o],O=await O,v&&setTimeout(Wt,n.dedupingInterval),!d[o]||d[o][1]!==w)return v&&T()&&S().onDiscarded(o),!1;j.error=_;const A=D[o];if(!c(A)&&(w<=A[0]||w<=A[1]||A[1]===0))return Mt(),v&&T()&&S().onDiscarded(o),!1;const P=x().data;j.data=u(P,O)?P:O,v&&T()&&S().onSuccess(O,o,n)}catch(A){Wt();const P=S(),{shouldRetryOnError:ut}=P;P.isPaused()||(j.error=A,v&&T()&&(P.onError(A,o,P),(ut===!0||V(ut)&&ut(A))&&(!S().revalidateOnFocus||!S().revalidateOnReconnect||$())&&P.onErrorRetry(A,o,P,ie=>{const lt=f[o];lt&&lt[0]&&lt[0](kt,ie)},{retryCount:(G.retryCount||0)+1,dedupe:!0})))}return L=!1,Mt(),!0},[o,s]),Ft=y.useCallback((...p)=>te(s,g.current,...p),[]);if(pt(()=>{b.current=e,k.current=n,c(J)||(ct.current=J)}),pt(()=>{if(!o)return;const p=Q.bind(_,wt);let h=0;S().revalidateOnFocus&&(h=Date.now()+S().focusThrottleInterval);const w=Ue(o,f,(L,G={})=>{if(L==Gt){const v=Date.now();S().revalidateOnFocus&&v>h&&$()&&(h=v+S().focusThrottleInterval,p())}else if(L==Yt)S().revalidateOnReconnect&&$()&&p();else{if(L==Xt)return Q();if(L==kt)return Q(G)}});return F.current=!1,g.current=o,X.current=!0,B({_k:nt}),Pt&&(c(H)||tt?p():ye(p)),()=>{F.current=!0,w()}},[o]),pt(()=>{let p;function h(){const w=V(C)?C(x().data):C;w&&p!==-1&&(p=setTimeout(O,w))}function O(){!x().error&&(m||S().isVisible())&&(a||S().isOnline())?Q(wt).then(h):h()}return h(),()=>{p&&(clearTimeout(p),p=-1)}},[C,m,a,o]),y.useDebugValue(ot),r&&c(H)&&o){if(!Bt&&tt)throw new Error("Fallback data is required when using Suspense in SSR.");b.current=e,k.current=n,F.current=!1;const p=q[o];if(!c(p)){const h=Ft(p);St(h)}if(c(rt)){const h=Q(wt);c(ot)||(h.status="fulfilled",h.value=!0),St(h)}else throw rt}return{mutate:Ft,get data(){return K.data=!0,ot},get error(){return K.error=!0,rt},get isValidating(){return K.isValidating=!0,re},get isLoading(){return K.isLoading=!0,oe}}},Je=qe(He);class ke{constructor(e={}){var n;this.apiKey=e.apiKey,this.username=e.username,this.password=e.password,this.accessToken=e.accessToken,this.basePath=e.basePath,this.serverIndex=e.serverIndex,this.baseOptions={...e.baseOptions,headers:{...(n=e.baseOptions)==null?void 0:n.headers}},this.formDataCtor=e.formDataCtor}isJsonMime(e){const n=new RegExp("^(application/json|[^;/ 	]+/[^;/ 	]+[+]json)[ 	]*(;.*)?$","i");return e!==null&&(n.test(e)||e.toLowerCase()==="application/json-patch+json")}}const Y=Jt.create({baseURL:"/api",headers:{"Content-Type":"application/json"}});let Z=null;Y.interceptors.response.use(t=>t,async t=>{const e=t.config;if(Z)return await Z,Y(e);if(t.response.status===ce.Unauthorized&&!e._retry){e._retry=!0;try{return Z=Jt.post("/auth/refresh-token").finally(()=>{Z=null}),await Z,Y(e)}catch(n){return window.location.href="/auth/logout",Promise.reject(n)}}return Promise.reject(t)});const Lt=new ke({basePath:"/api"}),Ge=new ue(Lt,bt,Y);new le(Lt,bt,Y);new fe(Lt,bt,Y);export{Ge as o,Je as u};
